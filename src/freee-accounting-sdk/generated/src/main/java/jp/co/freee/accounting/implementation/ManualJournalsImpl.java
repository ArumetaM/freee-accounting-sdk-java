/**
 * Copyright (c) freee K.K. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 *
 */

package jp.co.freee.accounting.implementation;

import retrofit2.Retrofit;
import jp.co.freee.accounting.ManualJournals;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import jp.co.freee.accounting.models.ManualJournalsCreateParams;
import jp.co.freee.accounting.models.ManualJournalsCreateResponse;
import jp.co.freee.accounting.models.ManualJournalsIndexResponse;
import jp.co.freee.accounting.models.ManualJournalsShowResponse;
import jp.co.freee.accounting.models.ManualJournalsUpdateParams;
import jp.co.freee.accounting.models.ManualJournalsUpdateResponse;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ManualJournals.
 */
public class ManualJournalsImpl implements ManualJournals {
    /** The Retrofit service to perform REST calls. */
    private ManualJournalsService service;
    /** The service client containing this operation class. */
    private AccountingClientImpl client;

    /**
     * Initializes an instance of ManualJournals.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ManualJournalsImpl(Retrofit retrofit, AccountingClientImpl client) {
        this.service = retrofit.create(ManualJournalsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ManualJournals to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ManualJournalsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: jp.co.freee.accounting.ManualJournals list" })
        @GET("manual_journals")
        Observable<Response<ResponseBody>> list(@Query("company_id") int companyId, @Query("start_issue_date") String startIssueDate, @Query("end_issue_date") String endIssueDate, @Query("entry_side") String entrySide, @Query("account_item_id") Integer accountItemId, @Query("min_amount") Integer minAmount, @Query("max_amount") Integer maxAmount, @Query("partner_id") Integer partnerId, @Query("partner_code") String partnerCode, @Query("item_id") Integer itemId, @Query("section_id") Integer sectionId, @Query("segment_1_tag_id") Integer segment1TagId, @Query("segment_2_tag_id") Integer segment2TagId, @Query("segment_3_tag_id") Integer segment3TagId, @Query("comment_status") String commentStatus, @Query("comment_important") Boolean commentImportant, @Query("adjustment") String adjustment, @Query("txn_number") String txnNumber, @Query("offset") Integer offset, @Query("limit") Integer limit);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: jp.co.freee.accounting.ManualJournals create" })
        @POST("manual_journals")
        Observable<Response<ResponseBody>> create(@Body ManualJournalsCreateParams parameters);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: jp.co.freee.accounting.ManualJournals get" })
        @GET("manual_journals/{id}")
        Observable<Response<ResponseBody>> get(@Path("id") int id, @Query("company_id") int companyId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: jp.co.freee.accounting.ManualJournals update" })
        @PUT("manual_journals/{id}")
        Observable<Response<ResponseBody>> update(@Path("id") int id, @Body ManualJournalsUpdateParams parameters);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: jp.co.freee.accounting.ManualJournals destroy" })
        @HTTP(path = "manual_journals/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> destroy(@Path("id") int id, @Query("company_id") int companyId);

    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsIndexResponse object if successful.
     */
    public ManualJournalsIndexResponse list(int companyId) {
        return listWithServiceResponseAsync(companyId).toBlocking().single().body();
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsIndexResponse> listAsync(int companyId, final ServiceCallback<ManualJournalsIndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(companyId), serviceCallback);
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsIndexResponse object
     */
    public Observable<ManualJournalsIndexResponse> listAsync(int companyId) {
        return listWithServiceResponseAsync(companyId).map(new Func1<ServiceResponse<ManualJournalsIndexResponse>, ManualJournalsIndexResponse>() {
            @Override
            public ManualJournalsIndexResponse call(ServiceResponse<ManualJournalsIndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsIndexResponse object
     */
    public Observable<ServiceResponse<ManualJournalsIndexResponse>> listWithServiceResponseAsync(int companyId) {
        final String startIssueDate = null;
        final String endIssueDate = null;
        final String entrySide = null;
        final Integer accountItemId = null;
        final Integer minAmount = null;
        final Integer maxAmount = null;
        final Integer partnerId = null;
        final String partnerCode = null;
        final Integer itemId = null;
        final Integer sectionId = null;
        final Integer segment1TagId = null;
        final Integer segment2TagId = null;
        final Integer segment3TagId = null;
        final String commentStatus = null;
        final Boolean commentImportant = null;
        final String adjustment = null;
        final String txnNumber = null;
        final Integer offset = null;
        final Integer limit = null;
        return service.list(companyId, startIssueDate, endIssueDate, entrySide, accountItemId, minAmount, maxAmount, partnerId, partnerCode, itemId, sectionId, segment1TagId, segment2TagId, segment3TagId, commentStatus, commentImportant, adjustment, txnNumber, offset, limit)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsIndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsIndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsIndexResponse> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @param startIssueDate 発生日で絞込：開始日(yyyy-mm-dd)
     * @param endIssueDate 発生日で絞込：終了日(yyyy-mm-dd)
     * @param entrySide 貸借で絞込 (貸方: credit, 借方: debit). Possible values include: 'credit', 'debit'
     * @param accountItemId 勘定科目IDで絞込
     * @param minAmount 金額で絞込：下限
     * @param maxAmount 金額で絞込：上限
     * @param partnerId 取引先IDで絞込（0を指定すると、取引先が未選択の貸借行を絞り込めます）
     * @param partnerCode 取引先コードで絞込
     * @param itemId 品目IDで絞込（0を指定すると、品目が未選択の貸借行を絞り込めます）
     * @param sectionId 部門IDで絞込（0を指定すると、部門が未選択の貸借行を絞り込めます）
     * @param segment1TagId セグメント１IDで絞り込み（0を指定すると、セグメント１が未選択の貸借行を絞り込めます）
     * @param segment2TagId セグメント２IDで絞り込み（0を指定すると、セグメント２が未選択の貸借行を絞り込めます）
     * @param segment3TagId セグメント３IDで絞り込み（0を指定すると、セグメント３が未選択の貸借行を絞り込めます）
     * @param commentStatus コメント状態で絞込（自分宛のコメント: posted_with_mention, 自分宛のコメント-未解決: raised_with_mention, 自分宛のコメント-解決済: resolved_with_mention, コメントあり: posted, 未解決: raised, 解決済: resolved, コメントなし: none）. Possible values include: 'posted_with_mention', 'raised_with_mention', 'resolved_with_mention', 'posted', 'raised', 'resolved', 'none'
     * @param commentImportant 重要コメント付きの振替伝票を絞込
     * @param adjustment 決算整理仕訳で絞込（決算整理仕訳のみ: only, 決算整理仕訳以外: without）. Possible values include: 'only', 'without'
     * @param txnNumber 仕訳番号で絞込（事業所の仕訳番号形式が有効な場合のみ）
     * @param offset 取得レコードのオフセット (デフォルト: 0)
     * @param limit 取得レコードの件数 (デフォルト: 20, 最大: 500)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsIndexResponse object if successful.
     */
    public ManualJournalsIndexResponse list(int companyId, String startIssueDate, String endIssueDate, String entrySide, Integer accountItemId, Integer minAmount, Integer maxAmount, Integer partnerId, String partnerCode, Integer itemId, Integer sectionId, Integer segment1TagId, Integer segment2TagId, Integer segment3TagId, String commentStatus, Boolean commentImportant, String adjustment, String txnNumber, Integer offset, Integer limit) {
        return listWithServiceResponseAsync(companyId, startIssueDate, endIssueDate, entrySide, accountItemId, minAmount, maxAmount, partnerId, partnerCode, itemId, sectionId, segment1TagId, segment2TagId, segment3TagId, commentStatus, commentImportant, adjustment, txnNumber, offset, limit).toBlocking().single().body();
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @param startIssueDate 発生日で絞込：開始日(yyyy-mm-dd)
     * @param endIssueDate 発生日で絞込：終了日(yyyy-mm-dd)
     * @param entrySide 貸借で絞込 (貸方: credit, 借方: debit). Possible values include: 'credit', 'debit'
     * @param accountItemId 勘定科目IDで絞込
     * @param minAmount 金額で絞込：下限
     * @param maxAmount 金額で絞込：上限
     * @param partnerId 取引先IDで絞込（0を指定すると、取引先が未選択の貸借行を絞り込めます）
     * @param partnerCode 取引先コードで絞込
     * @param itemId 品目IDで絞込（0を指定すると、品目が未選択の貸借行を絞り込めます）
     * @param sectionId 部門IDで絞込（0を指定すると、部門が未選択の貸借行を絞り込めます）
     * @param segment1TagId セグメント１IDで絞り込み（0を指定すると、セグメント１が未選択の貸借行を絞り込めます）
     * @param segment2TagId セグメント２IDで絞り込み（0を指定すると、セグメント２が未選択の貸借行を絞り込めます）
     * @param segment3TagId セグメント３IDで絞り込み（0を指定すると、セグメント３が未選択の貸借行を絞り込めます）
     * @param commentStatus コメント状態で絞込（自分宛のコメント: posted_with_mention, 自分宛のコメント-未解決: raised_with_mention, 自分宛のコメント-解決済: resolved_with_mention, コメントあり: posted, 未解決: raised, 解決済: resolved, コメントなし: none）. Possible values include: 'posted_with_mention', 'raised_with_mention', 'resolved_with_mention', 'posted', 'raised', 'resolved', 'none'
     * @param commentImportant 重要コメント付きの振替伝票を絞込
     * @param adjustment 決算整理仕訳で絞込（決算整理仕訳のみ: only, 決算整理仕訳以外: without）. Possible values include: 'only', 'without'
     * @param txnNumber 仕訳番号で絞込（事業所の仕訳番号形式が有効な場合のみ）
     * @param offset 取得レコードのオフセット (デフォルト: 0)
     * @param limit 取得レコードの件数 (デフォルト: 20, 最大: 500)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsIndexResponse> listAsync(int companyId, String startIssueDate, String endIssueDate, String entrySide, Integer accountItemId, Integer minAmount, Integer maxAmount, Integer partnerId, String partnerCode, Integer itemId, Integer sectionId, Integer segment1TagId, Integer segment2TagId, Integer segment3TagId, String commentStatus, Boolean commentImportant, String adjustment, String txnNumber, Integer offset, Integer limit, final ServiceCallback<ManualJournalsIndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(companyId, startIssueDate, endIssueDate, entrySide, accountItemId, minAmount, maxAmount, partnerId, partnerCode, itemId, sectionId, segment1TagId, segment2TagId, segment3TagId, commentStatus, commentImportant, adjustment, txnNumber, offset, limit), serviceCallback);
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @param startIssueDate 発生日で絞込：開始日(yyyy-mm-dd)
     * @param endIssueDate 発生日で絞込：終了日(yyyy-mm-dd)
     * @param entrySide 貸借で絞込 (貸方: credit, 借方: debit). Possible values include: 'credit', 'debit'
     * @param accountItemId 勘定科目IDで絞込
     * @param minAmount 金額で絞込：下限
     * @param maxAmount 金額で絞込：上限
     * @param partnerId 取引先IDで絞込（0を指定すると、取引先が未選択の貸借行を絞り込めます）
     * @param partnerCode 取引先コードで絞込
     * @param itemId 品目IDで絞込（0を指定すると、品目が未選択の貸借行を絞り込めます）
     * @param sectionId 部門IDで絞込（0を指定すると、部門が未選択の貸借行を絞り込めます）
     * @param segment1TagId セグメント１IDで絞り込み（0を指定すると、セグメント１が未選択の貸借行を絞り込めます）
     * @param segment2TagId セグメント２IDで絞り込み（0を指定すると、セグメント２が未選択の貸借行を絞り込めます）
     * @param segment3TagId セグメント３IDで絞り込み（0を指定すると、セグメント３が未選択の貸借行を絞り込めます）
     * @param commentStatus コメント状態で絞込（自分宛のコメント: posted_with_mention, 自分宛のコメント-未解決: raised_with_mention, 自分宛のコメント-解決済: resolved_with_mention, コメントあり: posted, 未解決: raised, 解決済: resolved, コメントなし: none）. Possible values include: 'posted_with_mention', 'raised_with_mention', 'resolved_with_mention', 'posted', 'raised', 'resolved', 'none'
     * @param commentImportant 重要コメント付きの振替伝票を絞込
     * @param adjustment 決算整理仕訳で絞込（決算整理仕訳のみ: only, 決算整理仕訳以外: without）. Possible values include: 'only', 'without'
     * @param txnNumber 仕訳番号で絞込（事業所の仕訳番号形式が有効な場合のみ）
     * @param offset 取得レコードのオフセット (デフォルト: 0)
     * @param limit 取得レコードの件数 (デフォルト: 20, 最大: 500)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsIndexResponse object
     */
    public Observable<ManualJournalsIndexResponse> listAsync(int companyId, String startIssueDate, String endIssueDate, String entrySide, Integer accountItemId, Integer minAmount, Integer maxAmount, Integer partnerId, String partnerCode, Integer itemId, Integer sectionId, Integer segment1TagId, Integer segment2TagId, Integer segment3TagId, String commentStatus, Boolean commentImportant, String adjustment, String txnNumber, Integer offset, Integer limit) {
        return listWithServiceResponseAsync(companyId, startIssueDate, endIssueDate, entrySide, accountItemId, minAmount, maxAmount, partnerId, partnerCode, itemId, sectionId, segment1TagId, segment2TagId, segment3TagId, commentStatus, commentImportant, adjustment, txnNumber, offset, limit).map(new Func1<ServiceResponse<ManualJournalsIndexResponse>, ManualJournalsIndexResponse>() {
            @Override
            public ManualJournalsIndexResponse call(ServiceResponse<ManualJournalsIndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票一覧の取得.
     * 指定した事業所の振替伝票一覧を取得する.
     *
     * @param companyId 事業所ID
     * @param startIssueDate 発生日で絞込：開始日(yyyy-mm-dd)
     * @param endIssueDate 発生日で絞込：終了日(yyyy-mm-dd)
     * @param entrySide 貸借で絞込 (貸方: credit, 借方: debit). Possible values include: 'credit', 'debit'
     * @param accountItemId 勘定科目IDで絞込
     * @param minAmount 金額で絞込：下限
     * @param maxAmount 金額で絞込：上限
     * @param partnerId 取引先IDで絞込（0を指定すると、取引先が未選択の貸借行を絞り込めます）
     * @param partnerCode 取引先コードで絞込
     * @param itemId 品目IDで絞込（0を指定すると、品目が未選択の貸借行を絞り込めます）
     * @param sectionId 部門IDで絞込（0を指定すると、部門が未選択の貸借行を絞り込めます）
     * @param segment1TagId セグメント１IDで絞り込み（0を指定すると、セグメント１が未選択の貸借行を絞り込めます）
     * @param segment2TagId セグメント２IDで絞り込み（0を指定すると、セグメント２が未選択の貸借行を絞り込めます）
     * @param segment3TagId セグメント３IDで絞り込み（0を指定すると、セグメント３が未選択の貸借行を絞り込めます）
     * @param commentStatus コメント状態で絞込（自分宛のコメント: posted_with_mention, 自分宛のコメント-未解決: raised_with_mention, 自分宛のコメント-解決済: resolved_with_mention, コメントあり: posted, 未解決: raised, 解決済: resolved, コメントなし: none）. Possible values include: 'posted_with_mention', 'raised_with_mention', 'resolved_with_mention', 'posted', 'raised', 'resolved', 'none'
     * @param commentImportant 重要コメント付きの振替伝票を絞込
     * @param adjustment 決算整理仕訳で絞込（決算整理仕訳のみ: only, 決算整理仕訳以外: without）. Possible values include: 'only', 'without'
     * @param txnNumber 仕訳番号で絞込（事業所の仕訳番号形式が有効な場合のみ）
     * @param offset 取得レコードのオフセット (デフォルト: 0)
     * @param limit 取得レコードの件数 (デフォルト: 20, 最大: 500)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsIndexResponse object
     */
    public Observable<ServiceResponse<ManualJournalsIndexResponse>> listWithServiceResponseAsync(int companyId, String startIssueDate, String endIssueDate, String entrySide, Integer accountItemId, Integer minAmount, Integer maxAmount, Integer partnerId, String partnerCode, Integer itemId, Integer sectionId, Integer segment1TagId, Integer segment2TagId, Integer segment3TagId, String commentStatus, Boolean commentImportant, String adjustment, String txnNumber, Integer offset, Integer limit) {
        return service.list(companyId, startIssueDate, endIssueDate, entrySide, accountItemId, minAmount, maxAmount, partnerId, partnerCode, itemId, sectionId, segment1TagId, segment2TagId, segment3TagId, commentStatus, commentImportant, adjustment, txnNumber, offset, limit)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsIndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsIndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsIndexResponse> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ManualJournalsIndexResponse> listDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<ManualJournalsIndexResponse, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ManualJournalsIndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsCreateResponse object if successful.
     */
    public ManualJournalsCreateResponse create() {
        return createWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsCreateResponse> createAsync(final ServiceCallback<ManualJournalsCreateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsCreateResponse object
     */
    public Observable<ManualJournalsCreateResponse> createAsync() {
        return createWithServiceResponseAsync().map(new Func1<ServiceResponse<ManualJournalsCreateResponse>, ManualJournalsCreateResponse>() {
            @Override
            public ManualJournalsCreateResponse call(ServiceResponse<ManualJournalsCreateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsCreateResponse object
     */
    public Observable<ServiceResponse<ManualJournalsCreateResponse>> createWithServiceResponseAsync() {
        final ManualJournalsCreateParams parameters = null;
        return service.create(parameters)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsCreateResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsCreateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsCreateResponse> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @param parameters 振替伝票の作成
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsCreateResponse object if successful.
     */
    public ManualJournalsCreateResponse create(ManualJournalsCreateParams parameters) {
        return createWithServiceResponseAsync(parameters).toBlocking().single().body();
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @param parameters 振替伝票の作成
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsCreateResponse> createAsync(ManualJournalsCreateParams parameters, final ServiceCallback<ManualJournalsCreateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(parameters), serviceCallback);
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @param parameters 振替伝票の作成
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsCreateResponse object
     */
    public Observable<ManualJournalsCreateResponse> createAsync(ManualJournalsCreateParams parameters) {
        return createWithServiceResponseAsync(parameters).map(new Func1<ServiceResponse<ManualJournalsCreateResponse>, ManualJournalsCreateResponse>() {
            @Override
            public ManualJournalsCreateResponse call(ServiceResponse<ManualJournalsCreateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の作成.
     * 指定した事業所の振替伝票を作成する.
     *
     * @param parameters 振替伝票の作成
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsCreateResponse object
     */
    public Observable<ServiceResponse<ManualJournalsCreateResponse>> createWithServiceResponseAsync(ManualJournalsCreateParams parameters) {
        Validator.validate(parameters);
        return service.create(parameters)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsCreateResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsCreateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsCreateResponse> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ManualJournalsCreateResponse> createDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<ManualJournalsCreateResponse, RestException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<ManualJournalsCreateResponse>() { }.getType())
                .build(response);
    }

    /**
     * 振替伝票の取得.
     * 指定した事業所の振替伝票を取得する.
     *
     * @param companyId 事業所ID
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsShowResponse object if successful.
     */
    public ManualJournalsShowResponse get(int companyId, int id) {
        return getWithServiceResponseAsync(companyId, id).toBlocking().single().body();
    }

    /**
     * 振替伝票の取得.
     * 指定した事業所の振替伝票を取得する.
     *
     * @param companyId 事業所ID
     * @param id the int value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsShowResponse> getAsync(int companyId, int id, final ServiceCallback<ManualJournalsShowResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(companyId, id), serviceCallback);
    }

    /**
     * 振替伝票の取得.
     * 指定した事業所の振替伝票を取得する.
     *
     * @param companyId 事業所ID
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsShowResponse object
     */
    public Observable<ManualJournalsShowResponse> getAsync(int companyId, int id) {
        return getWithServiceResponseAsync(companyId, id).map(new Func1<ServiceResponse<ManualJournalsShowResponse>, ManualJournalsShowResponse>() {
            @Override
            public ManualJournalsShowResponse call(ServiceResponse<ManualJournalsShowResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の取得.
     * 指定した事業所の振替伝票を取得する.
     *
     * @param companyId 事業所ID
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsShowResponse object
     */
    public Observable<ServiceResponse<ManualJournalsShowResponse>> getWithServiceResponseAsync(int companyId, int id) {
        return service.get(id, companyId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsShowResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsShowResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsShowResponse> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ManualJournalsShowResponse> getDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<ManualJournalsShowResponse, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ManualJournalsShowResponse>() { }.getType())
                .build(response);
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsUpdateResponse object if successful.
     */
    public ManualJournalsUpdateResponse update(int id) {
        return updateWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsUpdateResponse> updateAsync(int id, final ServiceCallback<ManualJournalsUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsUpdateResponse object
     */
    public Observable<ManualJournalsUpdateResponse> updateAsync(int id) {
        return updateWithServiceResponseAsync(id).map(new Func1<ServiceResponse<ManualJournalsUpdateResponse>, ManualJournalsUpdateResponse>() {
            @Override
            public ManualJournalsUpdateResponse call(ServiceResponse<ManualJournalsUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsUpdateResponse object
     */
    public Observable<ServiceResponse<ManualJournalsUpdateResponse>> updateWithServiceResponseAsync(int id) {
        final ManualJournalsUpdateParams parameters = null;
        return service.update(id, parameters)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsUpdateResponse> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @param parameters 振替伝票の更新
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManualJournalsUpdateResponse object if successful.
     */
    public ManualJournalsUpdateResponse update(int id, ManualJournalsUpdateParams parameters) {
        return updateWithServiceResponseAsync(id, parameters).toBlocking().single().body();
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @param parameters 振替伝票の更新
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManualJournalsUpdateResponse> updateAsync(int id, ManualJournalsUpdateParams parameters, final ServiceCallback<ManualJournalsUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(id, parameters), serviceCallback);
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @param parameters 振替伝票の更新
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsUpdateResponse object
     */
    public Observable<ManualJournalsUpdateResponse> updateAsync(int id, ManualJournalsUpdateParams parameters) {
        return updateWithServiceResponseAsync(id, parameters).map(new Func1<ServiceResponse<ManualJournalsUpdateResponse>, ManualJournalsUpdateResponse>() {
            @Override
            public ManualJournalsUpdateResponse call(ServiceResponse<ManualJournalsUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の更新.
     * 指定した事業所の振替伝票を更新する.
     *
     * @param id the int value
     * @param parameters 振替伝票の更新
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManualJournalsUpdateResponse object
     */
    public Observable<ServiceResponse<ManualJournalsUpdateResponse>> updateWithServiceResponseAsync(int id, ManualJournalsUpdateParams parameters) {
        Validator.validate(parameters);
        return service.update(id, parameters)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManualJournalsUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<ManualJournalsUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManualJournalsUpdateResponse> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ManualJournalsUpdateResponse> updateDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<ManualJournalsUpdateResponse, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ManualJournalsUpdateResponse>() { }.getType())
                .build(response);
    }

    /**
     * 振替伝票の削除.
     * 指定した事業所の振替伝票を削除する.
     *
     * @param id the int value
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void destroy(int id, int companyId) {
        destroyWithServiceResponseAsync(id, companyId).toBlocking().single().body();
    }

    /**
     * 振替伝票の削除.
     * 指定した事業所の振替伝票を削除する.
     *
     * @param id the int value
     * @param companyId 事業所ID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> destroyAsync(int id, int companyId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(destroyWithServiceResponseAsync(id, companyId), serviceCallback);
    }

    /**
     * 振替伝票の削除.
     * 指定した事業所の振替伝票を削除する.
     *
     * @param id the int value
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> destroyAsync(int id, int companyId) {
        return destroyWithServiceResponseAsync(id, companyId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * 振替伝票の削除.
     * 指定した事業所の振替伝票を削除する.
     *
     * @param id the int value
     * @param companyId 事業所ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> destroyWithServiceResponseAsync(int id, int companyId) {
        return service.destroy(id, companyId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = destroyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> destroyDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
